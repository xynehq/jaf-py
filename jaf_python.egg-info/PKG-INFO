Metadata-Version: 2.4
Name: jaf-python
Version: 2.0.0
Summary: A purely functional agent framework with immutable state and composable tools - Python implementation
Author: JAF Contributors
License: MIT
Project-URL: Homepage, https://github.com/juspay/jaf-python
Project-URL: Repository, https://github.com/juspay/jaf-python
Project-URL: Documentation, https://github.com/juspay/jaf-python#readme
Project-URL: Issues, https://github.com/juspay/jaf-python/issues
Keywords: ai,agents,functional,python,llm
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: pydantic>=2.0.0
Requires-Dist: fastapi>=0.104.0
Requires-Dist: uvicorn[standard]>=0.24.0
Requires-Dist: openai>=1.0.0
Requires-Dist: typing-extensions>=4.5.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.21.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: black>=23.0.0; extra == "dev"
Requires-Dist: isort>=5.12.0; extra == "dev"
Requires-Dist: mypy>=1.5.0; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"
Provides-Extra: server
Requires-Dist: uvicorn[standard]>=0.24.0; extra == "server"
Provides-Extra: memory
Requires-Dist: redis>=5.0.0; extra == "memory"
Requires-Dist: psycopg2-binary>=2.9.0; extra == "memory"
Provides-Extra: all
Requires-Dist: jaf-python[dev,memory,server]; extra == "all"

# JAF (Juspay Agent Framework) - Python Implementation

A purely functional agent framework with immutable state and composable tools, converted from TypeScript to Python. JAF enables building production-ready AI agent systems with built-in security, observability, and error handling.

## üéØ Core Philosophy

- **Immutability**: All core data structures are deeply immutable
- **Pure Functions**: Core logic expressed as pure, predictable functions
- **Effects at the Edge**: Side effects isolated in Provider modules
- **Composition over Configuration**: Build complex behavior by composing simple functions
- **Type-Safe by Design**: Leverages Python's type system with Pydantic for runtime safety

## üöÄ Quick Start

### Installation

```bash
pip install jaf-python
```

### Development Setup

```bash
git clone https://github.com/juspay/jaf-python
cd jaf-python
pip install -e ".[dev]"
pytest  # Run tests
```

## üìÅ Project Structure

```
jaf/
‚îú‚îÄ‚îÄ core/           # Core framework types and engine
‚îú‚îÄ‚îÄ providers/      # External integrations (LLM, MCP)
‚îú‚îÄ‚îÄ policies/       # Validation and security policies
‚îú‚îÄ‚îÄ server/         # FastAPI HTTP server
‚îî‚îÄ‚îÄ __init__.py     # Main exports
examples/
‚îî‚îÄ‚îÄ server_demo.py  # Complete server demo
tests/              # Test suite
```

## üèóÔ∏è Key Components

### Core Types

```python
from dataclasses import dataclass
from pydantic import BaseModel, Field
from jaf import Agent, Tool, RunState, run

# Define your context type
@dataclass
class MyContext:
    user_id: str
    permissions: list[str]

# Define tool schema
class CalculateArgs(BaseModel):
    expression: str = Field(description="Math expression to evaluate")

# Create a tool
class CalculatorTool:
    @property
    def schema(self):
        return type('ToolSchema', (), {
            'name': 'calculate',
            'description': 'Perform mathematical calculations',
            'parameters': CalculateArgs
        })()
    
    async def execute(self, args: CalculateArgs, context: MyContext) -> str:
        result = eval(args.expression)  # Don't do this in production!
        return f"{args.expression} = {result}"

# Define an agent
def create_math_agent():
    def instructions(state):
        return 'You are a helpful math tutor'
    
    return Agent(
        name='MathTutor',
        instructions=instructions,
        tools=[CalculatorTool()]
    )
```

### Running the Framework

```python
import asyncio
from jaf import run, make_litellm_provider, generate_run_id, generate_trace_id
from jaf.core.types import RunState, RunConfig, Message

async def main():
    model_provider = make_litellm_provider('http://localhost:4000')
    math_agent = create_math_agent()
    
    config = RunConfig(
        agent_registry={'MathTutor': math_agent},
        model_provider=model_provider,
        max_turns=10,
        on_event=lambda event: print(event),  # Real-time tracing
    )
    
    initial_state = RunState(
        run_id=generate_run_id(),
        trace_id=generate_trace_id(),
        messages=[Message(role='user', content='What is 2 + 2?')],
        current_agent_name='MathTutor',
        context=MyContext(user_id='user123', permissions=['user']),
        turn_count=0,
    )
    
    result = await run(initial_state, config)
    print(result.outcome.output if result.outcome.status == 'completed' else result.outcome.error)

asyncio.run(main())
```

## üõ°Ô∏è Security & Validation

### Composable Validation Policies

```python
from jaf.policies.validation import create_path_validator, create_permission_validator, compose_validations

# Create individual validators
path_validator = create_path_validator(['/shared', '/public'])
permission_validator = create_permission_validator('admin', lambda ctx: ctx)

# Compose them
combined_validator = compose_validations(path_validator, permission_validator)

# Apply to tools
secure_file_tool = with_validation(base_file_tool, combined_validator)
```

### Guardrails

```python
from jaf.policies.validation import create_content_filter, create_rate_limiter

config = RunConfig(
    # ... other config
    initial_input_guardrails=[
        create_content_filter(),
        create_rate_limiter(10, 60000, lambda input: 'global')
    ],
    final_output_guardrails=[
        create_content_filter()
    ],
)
```

## üîó Agent Handoffs

```python
from jaf.policies.handoff import handoff_tool
from pydantic import BaseModel
from enum import Enum

class AgentName(str, Enum):
    MATH_TUTOR = 'MathTutor'
    FILE_MANAGER = 'FileManager'

class HandoffOutput(BaseModel):
    agent_name: AgentName

def create_triage_agent():
    def instructions(state):
        return 'Route requests to specialized agents'
    
    return Agent(
        name='TriageAgent',
        instructions=instructions,
        tools=[handoff_tool],
        handoffs=['MathTutor', 'FileManager'],  # Allowed handoff targets
        output_schema=HandoffOutput,
    )
```

## üìä Observability

### Real-time Tracing

```python
from jaf.core.tracing import ConsoleTraceCollector, FileTraceCollector, create_composite_trace_collector

# Console logging
console_tracer = ConsoleTraceCollector()

# File logging
file_tracer = FileTraceCollector('./traces.log')

# Composite tracing
tracer = create_composite_trace_collector(console_tracer, file_tracer)

config = RunConfig(
    # ... other config
    on_event=tracer.collect,
)
```

### Error Handling

```python
from jaf.core.errors import JAFErrorHandler

if result.outcome.status == 'error':
    formatted_error = JAFErrorHandler.format(result.outcome.error)
    is_retryable = JAFErrorHandler.is_retryable(result.outcome.error)
    severity = JAFErrorHandler.get_severity(result.outcome.error)
    
    print(f"[{severity}] {formatted_error} (retryable: {is_retryable})")
```

## üîå Provider Integrations

### LiteLLM Provider

```python
from jaf.providers.model import make_litellm_provider

# Connect to LiteLLM proxy for 100+ model support
model_provider = make_litellm_provider(
    'http://localhost:4000',  # LiteLLM proxy URL
    'your-api-key'           # Optional API key
)
```

### MCP (Model Context Protocol) Tools

```python
from jaf.providers.mcp import make_mcp_client, mcp_tool_to_jaf_tool

# Connect to MCP server
mcp_client = await make_mcp_client('python', ['-m', 'mcp_server'])

# Get available tools
mcp_tools = await mcp_client.list_tools()

# Convert to JAF tools with validation
jaf_tools = [
    mcp_tool_to_jaf_tool(mcp_client, tool, my_validation_policy) 
    for tool in mcp_tools
]
```

## üöÄ Development Server

JAF includes a built-in development server for testing agents locally via HTTP endpoints:

```python
from jaf.server import run_server
from jaf.providers.model import make_litellm_provider

def create_my_agent():
    def instructions(state):
        return 'You are a helpful assistant'
    
    return Agent(
        name='MyAgent',
        instructions=instructions,
        tools=[calculator_tool, greeting_tool]
    )

model_provider = make_litellm_provider('http://localhost:4000')

# Start server on port 3000
await run_server(
    [create_my_agent()], 
    {'model_provider': model_provider},
    {'port': 3000}
)
```

Server provides RESTful endpoints:
- `GET /health` - Health check
- `GET /agents` - List available agents  
- `POST /chat` - General chat endpoint
- `POST /agents/{name}/chat` - Agent-specific endpoint

## üéÆ Example Applications

Explore the example applications to see the framework in action:

### Development Server Demo

```bash
cd examples
python server_demo.py
```

The server demo showcases:
- ‚úÖ Multiple agent types with different capabilities
- ‚úÖ RESTful API with type-safe validation
- ‚úÖ Tool integration (calculator, greeting)
- ‚úÖ Real-time tracing and error handling
- ‚úÖ CORS support and graceful shutdown

## üß™ Testing

```bash
pytest          # Run tests
ruff check .    # Lint code
mypy .          # Type checking
black .         # Format code
```

## üèõÔ∏è Architecture Principles

### Immutable State Machine
- All state transformations create new state objects
- No mutation of existing data structures
- Predictable, testable state transitions

### Type Safety
- Runtime validation with Pydantic schemas
- Compile-time safety with Python type hints
- NewType for type-safe identifiers

### Pure Functions
- Core logic is side-effect free
- Easy to test and reason about
- Deterministic behavior

### Effect Isolation
- Side effects only in Provider modules
- Clear boundaries between pure and impure code
- Easier mocking and testing

## üìú License

MIT

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Run the test suite
5. Submit a pull request

---

**FAF v2.0** - Building the future of functional AI agent systems üöÄ
